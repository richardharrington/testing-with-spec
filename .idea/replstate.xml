<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1489888580744">{:repl-history {:ide [], :local [&quot;(tc/quick-check 10000 prop-sorted-first-less-than-last)&quot; &quot;(double-it-unless-it-is-over-100-in-which-case-return-42 76)&quot; &quot;(double-it-unless-it-is-over-100-in-which-case-return-42 99)&quot; &quot;(double-it-unless-it-is-over-100-in-which-case-return-42 100)&quot; &quot;(double-it-unless-it-is-over-100-in-which-case-return-42 101)&quot; &quot;(stest/summarize-results (stest/check 'double-it-with-a-twist))&quot; &quot;(stest/check `double-it-with-a-twist)&quot; &quot;(stest/summarize-results (stest/check `double-it-with-a-twist))&quot; &quot;(run-all-tests)&quot; &quot;(t/run-all-tests)&quot; &quot;(t/run-all-tests #\&quot;.*test\&quot;)&quot; &quot;(def ascending? &lt;=)&quot; &quot;(def ascending? (partial apply &lt;=))&quot; &quot;(ascending? [4 5 6 7 8])&quot; &quot;(ascending? [4 5 6 7 7 8])&quot; &quot;(ascending? [4 5 6 7 6 7 8])&quot; &quot;(ascending? [48])&quot; &quot;(defn ascending2?\n  \&quot;clojure.core/sorted? doesn't do what we might expect, so we write our\n  own function\&quot;\n  [coll]\n  (every? (fn [[a b]] (&lt;= a b))\n          (partition 2 1 coll)))&quot; &quot;(ascending2? [])&quot; &quot;(ascending2? [4])&quot; &quot;(defn ascending? [coll]\n  (or (empty? coll)\n      (apply &lt;= coll)))&quot; &quot;(ascending? [])&quot; &quot;(ascending? [4])&quot; &quot;(ascending? [4 3])&quot; &quot;(def p\n  (tcprop/for-all [v (tcgen/vector tcgen//int)]\n                  (let [s (sort v)]\n                    (and (= (count v) (count s))\n                         (ascending? s)))))&quot; &quot;(def p\n  (tcprop/for-all [v (tcgen/vector tcgen/int)]\n                  (let [s (sort v)]\n                    (and (= (count v) (count s))\n                         (ascending? s)))))&quot; &quot;(def p\n  (tcprop/for-all [v (tcgen/vector tcgen/int)]\n                  (let [s v]\n                    (and (= (count v) (count s))\n                         (ascending? s)))))&quot; &quot;(tc/quick-check 100 p)&quot; &quot;(gen/sample gen/int 20)&quot; &quot;(tcgen/sample tcgen/int 20)&quot; &quot;(sgen/sample sgen/int 20)&quot; &quot;(sgen/sample int? 20)&quot; &quot;(sgen/sample (sgen/generate int?) 20)&quot; &quot;(sgen/sample (s/gen int?) 20)&quot; &quot;(sgen/sample (s/gen int?) 200)&quot; &quot;(tcgen/sample tcgen/int )&quot; &quot;(take 30 (tcgen/sample-seq gen/int))&quot; &quot;(take 30 (tcgen/sample-seq tcgen/int))&quot; &quot;(tcgen/sample (tcgen/tuple tcgen/nat tcgen/boolean tcgen/ratio))&quot; &quot;(tcgen/sample (s/gen (s/coll-of nat-int? :kind vector?)))&quot; &quot;(sgen/sample (s/gen (s/coll-of nat-int? :kind vector?)))&quot; &quot;(tcgen/sample (tcgen/vector tcgen/nat))&quot; &quot;(sgen/sample (s/gen (s/vector-of nat-int?)))&quot; &quot;(sgen/sample (s/gen (s/cat nat-int? boolean? ratio?)))&quot; &quot;(sgen/sample (s/gen (s/cat :a nat-int? :b boolean? :c ratio?)))&quot; &quot;(tcgen/sample (s/gen (s/cat :a nat-int? :b boolean? :c ratio?)))&quot; &quot;(tcgen/sample (tcgen/fmap set (gen/vector gen/nat)))&quot; &quot;(tcgen/sample (tcgen/fmap set (tcgen/vector tcgen/nat)))&quot; &quot;(sgen/sample (s/gen (s/coll-of nat-int? :kind set?)))&quot; &quot;(tcgen/sample (tcgen/such-that not-empty (tcgen/list tcgen/boolean)))&quot; &quot;(tcgen/sample (tcgen/such-that not-empty (tcgen/vector tcgen/boolean)))&quot; &quot;(tcgen/sample (tcgen/such-that not-empty (tcgen/set tcgen/boolean)))&quot; &quot;(tcgen/sample (tcgen/such-that not-empty (tcgen/set tcgen/boolean)) 100)&quot; &quot;(tcgen/sample (tcgen/such-that empty? (tcgen/set tcgen/boolean)) 100)&quot; &quot;(defrecord User [user-name user-id email active?])&quot; &quot;(-&gt;User \&quot;me\&quot; 13 \&quot;a@b.com\&quot; true)&quot; &quot;(def domain (tcgen/elements [\&quot;gmail.com\&quot; \&quot;hotmail.com\&quot; \&quot;computer.org\&quot;]))&quot; &quot;(def email-gen\n  (tcgen/fmap (fn [[name domain-name]]\n                (str name \&quot;@\&quot; domain-name))\n              (tcgen/tuple (tcgen/not-empty tcgen/string-alphanumeric) domain)))&quot; &quot;(last (tcgen/sample email-gen))&quot; &quot;last (tcgen/sample email-gen)&quot; &quot;(def user-gen\n  (tcgen/fmap (partial apply -&gt;User)\n              (tcgen/tuple (tcgen/not-empty tcgen/string-alphanumeric)\n                           tcgen/nat\n                           email-gen\n                           tcgen/boolean)))&quot; &quot;(tcgen/sample user-gen)&quot; &quot;(s/def ::domain-simple #{\&quot;gmail.com\&quot; \&quot;hotmail.com\&quot; \&quot;computer.org\&quot;})&quot; &quot;(s/conform ::domain-simple \&quot;hotmail.com\&quot;)&quot; &quot;(s/def ::domain (s/or :gmail \&quot;gmail.com\&quot; :hotmail \&quot;hotmail.com\&quot; :computer \&quot;computer.org\&quot;))&quot; &quot;(s/def ::domain (s/or :gmail #{\&quot;gmail.com\&quot;} :hotmail #{\&quot;hotmail.com\&quot;} :computer #{\&quot;computer.org\&quot;}))&quot; &quot;(s/valid? ::domain \&quot;hotmail.com\&quot;)&quot; &quot;(s/def ::domain #{\&quot;gmail.com\&quot; \&quot;hotmail.com\&quot; \&quot;computer.org\&quot;})&quot; &quot;(s/conform ::domain \&quot;hotmail.com\&quot;)&quot; &quot;(s/exercise ::domain)&quot; &quot;(sgen/sample (s/gen ::domain))&quot; &quot;(tcgen/sample (s/gen ::domain))&quot; &quot;(s/describe ::domain)&quot; &quot;(s/def ::name (s/and string? not-empty #\&quot;[0-9A-Za-z_]+\&quot;))&quot; &quot;(s/def ::name (s/and string? not-empty (partial re-matches #\&quot;[0-9A-Za-z_]+\&quot;)))&quot; &quot;(s/exercise ::name)&quot; &quot;(s/def ::email #(let [[name domain-name] (clojure.string/split % #\&quot;@\&quot;)]\n                 (and (s/valid? ::name name))\n                      (s/valid? ::domain domain-name)))&quot; &quot;(s/conform ::email \&quot;richad@hotmail.com\&quot;)&quot; &quot;(s/conform ::email \&quot;richad@hotmail.co\&quot;)&quot; &quot;(s/def ::email (s/with-gen #(let [[name domain-name] (clojure.string/split % #\&quot;@\&quot;)]\n                             (and (s/valid? ::name name))\n                             (s/valid? ::domain domain-name))\n                           (tcgen/fmap (fn [[name domain-name]]\n                                         (str name \&quot;@\&quot; domain-name))\n                                       (tcgen/tuple (tcgen/not-empty tcgen/string-alphanumeric) domain))))&quot; &quot;(s/explain ::email \&quot;richad@hotmail.co\&quot;)&quot; &quot;(s/def ::email (s/with-gen #(let [[name domain-name] (clojure.string/split % #\&quot;@\&quot;)]\n                             (and (s/valid? ::name name))\n                             (s/valid? ::domain domain-name))\n                           #(tcgen/fmap (fn [[name domain-name]]\n                                          (str name \&quot;@\&quot; domain-name))\n                                        (tcgen/tuple (tcgen/not-empty tcgen/string-alphanumeric) domain))))&quot; &quot;(s/describe ::email)&quot; &quot;(sgen/stri)&quot; &quot;(s/def ::email (s/with-gen #(let [[name domain-name] (clojure.string/split % #\&quot;@\&quot;)]\n                             (and (s/valid? ::name name))\n                             (s/valid? ::domain domain-name))\n                           #(sgen/fmap (fn [[name domain-name]]\n                                          (str name \&quot;@\&quot; domain-name))\n                                        (sgen/tuple (sgen/not-empty sgen/string-alphanumeric) domain))))&quot; &quot;(s/def ::email (s/with-gen #(let [[name domain-name] (clojure.string/split % #\&quot;@\&quot;)]\n                             (and (s/valid? ::name name))\n                             (s/valid? ::domain domain-name))\n                           #(sgen/fmap (fn [[name domain-name]]\n                                          (str name \&quot;@\&quot; domain-name))\n                                        (sgen/tuple (sgen/not-empty tcgen/string-alphanumeric) domain))))&quot; &quot;(s/def ::email (s/with-gen #(let [[name domain-name] (clojure.string/split % #\&quot;@\&quot;)]\n                             (and (s/valid? ::name name))\n                             (s/valid? ::domain domain-name))\n                           #(sgen/fmap (fn [[name domain-name]]\n                                          (str name \&quot;@\&quot; domain-name))\n                                        (sgen/tuple (sgen/such-that (complement #{\&quot;\&quot;}) sgen/string-alphanumeric) domain))))&quot; &quot;sgen/string-alphanumeric&quot; &quot;(type sgen/tuple)&quot; &quot;(type sgen/string-alphanumeric)&quot; &quot;(sgen/sample sgen/tuple)&quot; &quot;(sgen/sample (s/gen int?))&quot; &quot;(sgen/sample sgen/int))&quot; &quot;(sgen/sample sgen/int)&quot; &quot;(sgen/sample #(sgen/int))&quot; &quot;(sgen/sample (constantly sgen/int))&quot; &quot;(s/def ::email (s/with-gen #(let [[name domain-name] (clojure.string/split % #\&quot;@\&quot;)]\n                             (and (s/valid? ::name name))\n                             (s/valid? ::domain domain-name))\n                           #(sgen/fmap (fn [[name domain-name]]\n                                          (str name \&quot;@\&quot; domain-name))\n                                        (sgen/tuple (sgen/not-empty (constantly gen/string-alphanumeric)) domain))))&quot; &quot;(s/def ::email (s/with-gen #(let [[name domain-name] (clojure.string/split % #\&quot;@\&quot;)]\n                             (and (s/valid? ::name name))\n                             (s/valid? ::domain domain-name))\n                           #(sgen/fmap (fn [[name domain-name]]\n                                          (str name \&quot;@\&quot; domain-name))\n                                        (sgen/tuple (sgen/not-empty (gen/string-alphanumeric)) domain))))&quot; &quot;(s/def ::email (s/with-gen #(let [[name domain-name] (clojure.string/split % #\&quot;@\&quot;)]\n                             (and (s/valid? ::name name))\n                             (s/valid? ::domain domain-name))\n                           #(sgen/fmap (fn [[name domain-name]]\n                                          (str name \&quot;@\&quot; domain-name))\n                                        (sgen/tuple (sgen/not-empty (sgen/string-alphanumeric)) domain))))&quot; &quot;(s/def ::email (s/with-gen #(let [[name domain-name] (clojure.string/split % #\&quot;@\&quot;)]\n                             (and (s/valid? ::name name)\n                                  (s/valid? ::domain domain-name)))\n                           #(sgen/fmap (fn [[name domain-name]]\n                                         (str name \&quot;@\&quot; domain-name))\n                                       (sgen/tuple (sgen/not-empty (sgen/string-alphanumeric)) domain))))&quot; &quot;(s/exercise ::email)&quot;], :remote []}}</component>
</project>